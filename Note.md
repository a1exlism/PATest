# Preface(前言)

记录coding过程中遇到的相关知识点
按两本书进度来写, 便于查找

## Requirement

>Chen Yue
首先有十分钟拿下乙级15分题的本事。
然后要能在半小时内完成乙级20分题1道。
接下来训练自己45分钟完成乙级25分题。
这时你有了2.5小时满乙级的本事！
下面改做甲级英文题。
要有用十分钟读完4题的本事。
20分钟写完20分题并至少过样例。
1小时内写完2道25分题并至少过样例。
1小时写完最难题并至少过样例。
此时你应该有70分左右了，
最后半小时拚命过90吧！

## type size

* int: -2^31 ~ 2^31-1 | 2\*10^9
* long long: -2^63 ~ 2^63-1 | 9\*10^18
* float:  2^128  精度6~7位
* double: 2^1024 精度15~16位
* char: -128 ~ 127

## 文件处理

* in File_operator

1. 注意在windows中用反斜杠, 加转义`\\`;
2. scanf/printf `f`prefix

## 算法笔记

### Chapter 3

#### B1036 隐式类型转换

```cpp
int z, y, x = 3;
y = round(x/2);   //  1
z = round(x/2.0); //  2
```

#### Codeup1928 日期间隔

日期计算方式思路很好: day by day

#### B1022/-X 进制转换

做法都是先`%`后`/`

* 十进制转D进制 do while格式
* D进制转十进制 while格式

看了一下1009的错误才知道Runtime Error的问题, 数组开的太小导致越界
[Runtime Error Refer](https://blog.csdn.net/user_longling/article/details/22488905)

#### B1009 倒序输出

```c++
char * fgets ( char * str, int num, FILE * stream );
//  num: 最大输入数量
//  strem: 输入流
```

* 实际读入的数据为num-1(考虑到`\n`和`\0`)
* gets函数不可使用, 换成`fgets(str, str_len, stdin)`
* fgets在最后会保留`\n`

hack code:
```c++
char str[101];
fgets(str, 101, stdin);
str[strlen(str)-1] = '\0';
```

#### 其他教训

* 输出百分号: `%%` 
* `strlen(str)/2`至少为str中值, arr下标以0为开始 
* 既定内存可以更大, 数组内存过少导致partitial accept
* for循环会让结构更清晰

[Refer](https://bbs.csdn.net/topics/310214704)

## 上机指南

### 3.1 基础模拟

#### B1011

主要问题在于题目中的范围: `[-2^31, 2^31]`
超过了int, 所以需要用`long long`并用`lld`来scanf

#### B1018

scanf的`%c`会读取换行符`\n`需要用getchar()吸收空格

#### B1026 程序运行时间

主要考察printf输出`格式`问题
还有一个就是考试过程中`禁用round`函数,替代方案如下

```c++
z = (x + 0.5) / d;
```

#### A1046

1. 数组定义需要注意`初始化`, 否则数据不准确
2. 注意运行时间, 减少循环.

#### A1065

1. long long范围: `[−2^63,2^​63​)`, scanf使用`%lld`
2. 边界判定取余操作max:2^63*2-2 % 2^64 = -2`右边界`, 左边界则为0
3. bool格式运用;

#### B1010

1. 未知数量的数据输入, 利用scanf返回值判断结束;
2. EOF:-1, windows: `ctrl-z`, mac: `ctrl-d`;
3. 递推最好以1为单位, 否则多余的考虑内容过多;
4. 在scanf和输入EOF上花了比较多的时间

#### A1002

1. 英文单词不认识, 题意理解不透彻;
2. 最好打草稿来理解题目陷阱;
3. 不够熟练.

### 3.2元素查找

#### B1041

1. 结构体定义和`typedef`;
2. scanf和结构体数组搭配;
3. PS: 利用string居然不给过;
4. 可以简化为单一循环, 不过预先需要给个大结构体数组;

#### B1004

1. 寻找max/min类型: init value可以设置为边界外部.
   Example: [0-100], min = 101, max = -1;
2. PAT的判断数据过少导致特殊情况也能返回答案正确

#### B1028 日期比较

1. 大小范围比较的🙅错误‍示范: `if(a<x<b)`;
2. 利用这个方案进行简化, (暂时不清楚是否有特殊问题;
   >BETTER: x = yy \* 10000 + mm \* 100 + dd;
3. 在合法性比较上缺少了对极端情况的判断, 所有数据均不合格
4. 题解上的日期判断也可以参考一下:

```cpp
bool MoreEqu(person a, person b) {
  if(a.yy != b.yy) return a.yy > b.yy
  else if(a.mm != b.mm) return a.mm > b.mm;
  else return a.dd > b.dd;
}
```

#### A1011

1. 赌博倍率题, 难点是英文理解; A类简单题

#### A1006

1. 和B1028基本一样; 另一种方式是转化为秒做, 不过感觉没有必要;

#### A1036

1. 理解corresponding含义

### 3.3 Graphic 图形输出

#### **B1027**

1. 花了整整50min, 对于row的计算没有把握好;

#### A1031

1. 做了这题才想到B1027与此题非常相似, 在算临界点的循环中若不符合条件, 应进行`后悔`操作.也就是`回退数据`!

### 日期处理

#### codeup 1928

1. 日期处理很麻烦, 一般就放弃了= =

### **进制转换**

#### B1022

1. while...do模式导致意外情况: A+B = 0

#### B1037

1. Simple-找零问题, 全化作基础单位进行计算, 之后单位化.

#### A1019

1. 除零会导致`floating point exception`;
2. 测试点3,运行超时 比较懵逼0307; 改了进制转换的算法之后问题消失, 蒙蔽.

#### A1027

1. 很大的障碍, 英语题意理解错误导致没看懂;
2. 设置字典dict进行字母映射;
3. 0的控制以string类型输出, 需要注意x个字母必须分配`x+1`空间, `str[x]='\0';`.

#### A1058

1. 与前面几个类似, 考察加法`进位`, 简单题.

### 字符串处理

#### WARNING: 关于结束符`\0`

0. `scanf("%s", str)`遇到空格也会停止接受数据;
1. gets/scanf在结尾会`自动去掉`换行符`\n`并添加`\0`作为结尾, 相应的空间-1;
2. fgets()读取单行数据, `保留`换行符`\n`, 并添加`\0`作为结尾, 相应空间-2(算上`\n`);
如下为fgets => gets
>str[strlen(str)-1] = '\0';

3. puts/printf通过识别`\0`作为输出结尾.
4. C++11 已经弃用gets, 转为`fgets`
>fgets(str, strlen(str), stdin/filepointer);

REFER-LINK: [C语言——输入输出函数](https://www.cnblogs.com/feipeng8848/p/7273939.html)

#### string.h

>strlen(str)a;
* `\0`为结尾

>strcpy(str_to, str_from);
* `\0`也会一同copy

>strcat(str_main, str_sub);
* concat

>memset(str|intA, val, sizeof(str));
* 数组初始化, int: `0/-1`

ATTENTION: int类型的数组初始化只能为0, 其他数字写上去不报错但不`执行`

#### StringIO | sscanf和sprintf的使用

1. 格式化内容赋值

#### B1006

1. 只需要正确处理求商取余即可, 简单题

#### B1021

1. 字数统计相关, 需要用到char数组;
2. char数组比较相关代码: `str[i] == '0'`, 顺序相关:0-9, a-z, A-Z;
3. 小写转大写: X代表'X', 转换:`X-'A'+'a'`, 依据相对位置;

#### B1031

1. 审题不清导致完全走偏方向;
2. 判负情况在循环状态下需要一个外部变量`Line 15`;

#### B1002

1. 较长的int连续输入处理`%s`;
2. 十进制的数据按位分割`split`处理;
3. 字典包处理, 二维数组.

#### B1009

1. WARNING, 这里需要强调一下scanf中的%s和%c的结束标志区别;

具体如下: 
* %s 以空格和换行作为读取`结束`标识符;
* %c `可以读入`空格和换行, 这也是为什么某些题目需要getchar来消除空格和回车的原因; 

2. 2nd判断需要添加对`'\n'`的检查

#### A1061/B1014

1. 主要是语意问题, character/capital.etc
2. 格式化输入: `%02d` prefix为0, 2位数

#### B1048

1. 主要难点在于输入是从前往后, 但是数据处理从后往前, 需要设计reverse函数以及合集str来进行两次reverse;
2. index从0开始的奇偶颠倒;

#### A1001

1. 简单题, 注意点: 001输出为`%03d`;
2. 另一种方式为数组reverse, %10 /10交替, 可以实现10^6以上数据的操作;

#### A1005

1. 简单题, 与A1001类似, 借用数组reverse和字典进行输出;
2. fgets读取之后需要`添加结束符`;
3. 判零情况大部分需要和do...while结合;
4. 递归本身就带有reverse性质, 可以使用递归来解决问题, 见A1005_recursion.cpp(然而正确输出但是oj全错...)

#### A1035

1. 简单题, 好像没啥注意点.

#### A1077

思路一开始就有, 但是实现的过程有点坎坷

1. 一行内`有空格`, 所以只能用fgets获取str;
2. 比较依然是从右往左, 所以需要reverse;
3. 需要一个对照组(common string), 作为最终的输出结果, 每次输入与其进行比较, 缩短comstr;

#### A1082

做的一头包, 参考了书, 通过分割片段实现`千百十`的输出;

1. 设计两个游标left,right以4为单位从高位移向低位, 在0-3循环中输出千百十;
2. 零的输出有两个要点, 一个是2+连续零的出现只能输出一个`ling`, 而且没有修饰, 另一个则是亿万的判断上需要注意例如`10000800`;
3. 亿万的输出条件需要打草稿, 代码考虑了最高12位的数字判定;